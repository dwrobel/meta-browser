Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/common/wayland_object.cc
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/common/wayland_object.cc
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/common/wayland_object.cc
@@ -10,8 +10,7 @@
 #include <text-input-unstable-v1-client-protocol.h>
 #include <wayland-client.h>
 #include <wayland-drm-client-protocol.h>
-#include <xdg-shell-client-protocol.h>
-#include <xdg-shell-unstable-v6-client-protocol.h>
+#include <xdg-shell-unstable-v5-client-protocol.h>
 
 namespace wl {
 namespace {
@@ -168,14 +167,17 @@ const wl_interface* ObjectTraits<struct
 void (*ObjectTraits<struct wp_presentation_feedback>::deleter)(
     struct wp_presentation_feedback*) = &wp_presentation_feedback_destroy;
 
+const wl_interface* ObjectTraits<xdg_shell>::interface = &xdg_shell_interface;
+void (*ObjectTraits<xdg_shell>::deleter)(xdg_shell*) = &xdg_shell_destroy;
+/*
 const wl_interface* ObjectTraits<xdg_wm_base>::interface =
     &xdg_wm_base_interface;
 void (*ObjectTraits<xdg_wm_base>::deleter)(xdg_wm_base*) = &xdg_wm_base_destroy;
-
+*/
 const wl_interface* ObjectTraits<xdg_surface>::interface =
     &xdg_surface_interface;
 void (*ObjectTraits<xdg_surface>::deleter)(xdg_surface*) = &xdg_surface_destroy;
-
+/*
 const wl_interface* ObjectTraits<xdg_toplevel>::interface =
     &xdg_toplevel_interface;
 void (*ObjectTraits<xdg_toplevel>::deleter)(xdg_toplevel*) =
@@ -188,12 +190,12 @@ const wl_interface* ObjectTraits<xdg_pos
     &xdg_positioner_interface;
 void (*ObjectTraits<xdg_positioner>::deleter)(xdg_positioner*) =
     &xdg_positioner_destroy;
-
+*/
 const wl_interface* ObjectTraits<zwp_linux_dmabuf_v1>::interface =
     &zwp_linux_dmabuf_v1_interface;
 void (*ObjectTraits<zwp_linux_dmabuf_v1>::deleter)(zwp_linux_dmabuf_v1*) =
     &zwp_linux_dmabuf_v1_destroy;
-
+/*
 const wl_interface* ObjectTraits<zxdg_shell_v6>::interface =
     &zxdg_shell_v6_interface;
 void (*ObjectTraits<zxdg_shell_v6>::deleter)(zxdg_shell_v6*) =
@@ -218,7 +220,7 @@ const wl_interface* ObjectTraits<zxdg_po
     &zxdg_positioner_v6_interface;
 void (*ObjectTraits<zxdg_positioner_v6>::deleter)(zxdg_positioner_v6*) =
     &zxdg_positioner_v6_destroy;
-
+*/
 const wl_interface* ObjectTraits<zwp_text_input_manager_v1>::interface =
     &zwp_text_input_manager_v1_interface;
 void (*ObjectTraits<zwp_text_input_manager_v1>::deleter)(
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/common/wayland_object.h
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/common/wayland_object.h
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/common/wayland_object.h
@@ -35,6 +35,7 @@ struct wl_touch;
 struct wp_presentation;
 struct wp_presentation_feedback;
 struct xdg_wm_base;
+struct xdg_shell;
 struct xdg_surface;
 struct xdg_toplevel;
 struct xdg_popup;
@@ -216,6 +217,12 @@ struct ObjectTraits<wp_presentation_feed
 };
 
 template <>
+struct ObjectTraits<xdg_shell> {
+  static const wl_interface* interface;
+  static void (*deleter)(xdg_shell*);
+};
+
+template <>
 struct ObjectTraits<xdg_wm_base> {
   static const wl_interface* interface;
   static void (*deleter)(xdg_wm_base*);
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/shell_object_factory.cc
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/shell_object_factory.cc
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/shell_object_factory.cc
@@ -5,7 +5,7 @@
 #include "ui/ozone/platform/wayland/host/shell_object_factory.h"
 
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
-#include "ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.h"
+//#include "ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.h"
 #include "ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h"
 
 namespace ui {
@@ -16,7 +16,7 @@ ShellObjectFactory::~ShellObjectFactory(
 std::unique_ptr<ShellSurfaceWrapper>
 ShellObjectFactory::CreateShellSurfaceWrapper(WaylandConnection* connection,
                                               WaylandWindow* wayland_window) {
-  if (connection->shell() || connection->shell_v6()) {
+  if (connection->shell_v5()) {
     auto surface =
         std::make_unique<XDGSurfaceWrapperImpl>(wayland_window, connection);
     return surface->Initialize(true /* with_top_level */) ? std::move(surface)
@@ -26,14 +26,15 @@ ShellObjectFactory::CreateShellSurfaceWr
   return nullptr;
 }
 
+/*
 std::unique_ptr<ShellPopupWrapper> ShellObjectFactory::CreateShellPopupWrapper(
     WaylandConnection* connection,
     WaylandWindow* wayland_window,
     const gfx::Rect& bounds) {
-  if (connection->shell() || connection->shell_v6()) {
+  if (connection->shell_v5()) {
     auto surface =
         std::make_unique<XDGSurfaceWrapperImpl>(wayland_window, connection);
-    if (!surface->Initialize(false /* with_top_level */))
+    if (!surface->Initialize(false / with_top_level /))
       return nullptr;
 
     auto popup = std::make_unique<XDGPopupWrapperImpl>(std::move(surface),
@@ -43,5 +44,5 @@ std::unique_ptr<ShellPopupWrapper> Shell
   LOG(WARNING) << "Shell protocol is not available.";
   return nullptr;
 }
-
-}  // namespace ui
\ No newline at end of file
+*/
+}  // namespace ui
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/wayland_connection.cc
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -4,8 +4,7 @@
 
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 
-#include <xdg-shell-client-protocol.h>
-#include <xdg-shell-unstable-v6-client-protocol.h>
+#include <xdg-shell-unstable-v5-client-protocol.h>
 #include <memory>
 
 #include <algorithm>
@@ -83,8 +82,8 @@ bool WaylandConnection::Initialize() {
     LOG(ERROR) << "No wl_shm object";
     return false;
   }
-  if (!shell_v6_ && !shell_) {
-    LOG(ERROR) << "No Wayland shell found";
+  if (!shell_v5_) {
+    LOG(ERROR) << "No Wayland shell v5 found";
     return false;
   }
 
@@ -278,13 +277,11 @@ void WaylandConnection::Global(void* dat
       &WaylandConnection::Capabilities,
       &WaylandConnection::Name,
   };
-  static const xdg_wm_base_listener shell_listener = {
-      &WaylandConnection::Ping,
+  
+  static const xdg_shell_listener shell_v5_listener = {
+      &WaylandConnection::PingV5,
   };
-  static const zxdg_shell_v6_listener shell_v6_listener = {
-      &WaylandConnection::PingV6,
-  };
-
+  
   WaylandConnection* connection = static_cast<WaylandConnection*>(data);
   if (!connection->compositor_ && strcmp(interface, "wl_compositor") == 0) {
     connection->compositor_ = wl::Bind<wl_compositor>(
@@ -312,27 +309,21 @@ void WaylandConnection::Global(void* dat
     }
     wl_seat_add_listener(connection->seat_.get(), &seat_listener, connection);
     connection->EnsureDataDevice();
-  } else if (!connection->shell_v6_ &&
-             strcmp(interface, "zxdg_shell_v6") == 0) {
-    // Check for zxdg_shell_v6 first.
-    connection->shell_v6_ = wl::Bind<zxdg_shell_v6>(
+  } else if (!connection->shell_v5_ &&
+             strcmp(interface, "xdg_shell") == 0) {
+    connection->shell_v5_ = wl::Bind<xdg_shell>(
         registry, name, std::min(version, kMaxXdgShellVersion));
-    if (!connection->shell_v6_) {
-      LOG(ERROR) << "Failed to bind to zxdg_shell_v6 global";
+    if (!connection->shell_v5_) {
+      LOG(ERROR) << "Failed to bind to xdg_shell global";
       return;
     }
-    zxdg_shell_v6_add_listener(connection->shell_v6_.get(), &shell_v6_listener,
+    xdg_shell_add_listener(connection->shell_v5_.get(), &shell_v5_listener,
                                connection);
-  } else if (!connection->shell_v6_ && !connection->shell_ &&
-             strcmp(interface, "xdg_wm_base") == 0) {
-    connection->shell_ = wl::Bind<xdg_wm_base>(
-        registry, name, std::min(version, kMaxXdgShellVersion));
-    if (!connection->shell_) {
-      LOG(ERROR) << "Failed to bind to xdg_wm_base global";
-      return;
-    }
-    xdg_wm_base_add_listener(connection->shell_.get(), &shell_listener,
-                             connection);
+                     
+    xdg_shell_use_unstable_version(connection->shell_v5_.get(),
+                                   XDG_SHELL_VERSION_CURRENT);
+
+
   } else if (base::EqualsCaseInsensitiveASCII(interface, "wl_output")) {
     if (version < kMinWlOutputVersion) {
       LOG(ERROR)
@@ -481,18 +472,11 @@ void WaylandConnection::Capabilities(voi
 void WaylandConnection::Name(void* data, wl_seat* seat, const char* name) {}
 
 // static
-void WaylandConnection::PingV6(void* data,
-                               zxdg_shell_v6* shell_v6,
+void WaylandConnection::PingV5(void* data,
+                               xdg_shell* shell_v5,
                                uint32_t serial) {
   WaylandConnection* connection = static_cast<WaylandConnection*>(data);
-  zxdg_shell_v6_pong(shell_v6, serial);
-  connection->ScheduleFlush();
-}
-
-// static
-void WaylandConnection::Ping(void* data, xdg_wm_base* shell, uint32_t serial) {
-  WaylandConnection* connection = static_cast<WaylandConnection*>(data);
-  xdg_wm_base_pong(shell, serial);
+  xdg_shell_pong(shell_v5, serial);
   connection->ScheduleFlush();
 }
 
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/wayland_connection.h
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/wayland_connection.h
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -54,8 +54,9 @@ class WaylandConnection : public Platfor
   wl_compositor* compositor() const { return compositor_.get(); }
   uint32_t compositor_version() const { return compositor_version_; }
   wl_subcompositor* subcompositor() const { return subcompositor_.get(); }
-  xdg_wm_base* shell() const { return shell_.get(); }
-  zxdg_shell_v6* shell_v6() const { return shell_v6_.get(); }
+//  xdg_wm_base* shell() const { return shell_.get(); }
+  xdg_shell* shell_v5() const { return shell_v5_.get(); }
+//  zxdg_shell_v6* shell_v6() const { return shell_v6_.get(); }
   wl_seat* seat() const { return seat_.get(); }
   wl_data_device* data_device() const { return data_device_->data_device(); }
   gtk_primary_selection_device* primary_selection_device() const {
@@ -172,10 +173,13 @@ class WaylandConnection : public Platfor
   static void Name(void* data, wl_seat* seat, const char* name);
 
   // zxdg_shell_v6_listener
-  static void PingV6(void* data, zxdg_shell_v6* zxdg_shell_v6, uint32_t serial);
+//  static void PingV6(void* data, zxdg_shell_v6* zxdg_shell_v6, uint32_t serial);
+
+  // xdg_shell_v5_listener
+  static void PingV5(void* data, xdg_shell* xdg_shell, uint32_t serial);
 
   // xdg_wm_base_listener
-  static void Ping(void* data, xdg_wm_base* shell, uint32_t serial);
+//  static void Ping(void* data, xdg_wm_base* shell, uint32_t serial);
 
   wl::Object<wl_display> display_;
   wl::Object<wl_registry> registry_;
@@ -183,8 +187,9 @@ class WaylandConnection : public Platfor
   uint32_t compositor_version_ = 0;
   wl::Object<wl_subcompositor> subcompositor_;
   wl::Object<wl_seat> seat_;
-  wl::Object<xdg_wm_base> shell_;
-  wl::Object<zxdg_shell_v6> shell_v6_;
+//  wl::Object<xdg_wm_base> shell_;
+  wl::Object<xdg_shell> shell_v5_;
+//  wl::Object<zxdg_shell_v6> shell_v6_;
   wl::Object<wp_presentation> presentation_;
   wl::Object<zwp_text_input_manager_v1> text_input_manager_v1_;
 
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
@@ -4,8 +4,7 @@
 
 #include "ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h"
 
-#include <xdg-shell-client-protocol.h>
-#include <xdg-shell-unstable-v6-client-protocol.h>
+#include <xdg-shell-unstable-v5-client-protocol.h>
 
 #include "base/strings/utf_string_conversions.h"
 #include "ui/base/hit_test.h"
@@ -22,314 +21,117 @@ XDGSurfaceWrapperImpl::XDGSurfaceWrapper
 XDGSurfaceWrapperImpl::~XDGSurfaceWrapperImpl() {}
 
 bool XDGSurfaceWrapperImpl::Initialize(bool with_toplevel) {
-  if (connection_->shell())
-    return InitializeStable(with_toplevel);
-  else if (connection_->shell_v6())
-    return InitializeV6(with_toplevel);
-  NOTREACHED() << "Wrong shell protocol";
-  return false;
+  return InitializeV5(with_toplevel);  
 }
 
 void XDGSurfaceWrapperImpl::SetMaximized() {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_maximized(xdg_toplevel_.get());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_maximized(zxdg_toplevel_v6_.get());
-  }
+  xdg_surface_set_maximized(xdg_surface_.get());
 }
 
 void XDGSurfaceWrapperImpl::UnSetMaximized() {
-  if (xdg_toplevel_) {
-    xdg_toplevel_unset_maximized(xdg_toplevel_.get());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_unset_maximized(zxdg_toplevel_v6_.get());
-  }
+  xdg_surface_unset_maximized(xdg_surface_.get());
 }
 
 void XDGSurfaceWrapperImpl::SetFullscreen() {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_fullscreen(xdg_toplevel_.get(), nullptr);
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_fullscreen(zxdg_toplevel_v6_.get(), nullptr);
-  }
+  LOG(ERROR) << "SetFullscreen V5 NotImplemented";
 }
 
 void XDGSurfaceWrapperImpl::UnSetFullscreen() {
-  if (xdg_toplevel_) {
-    xdg_toplevel_unset_fullscreen(xdg_toplevel_.get());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_unset_fullscreen(zxdg_toplevel_v6_.get());
-  }
+  xdg_surface_unset_fullscreen(xdg_surface_.get());
 }
 
 void XDGSurfaceWrapperImpl::SetMinimized() {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_minimized(xdg_toplevel_.get());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_minimized(zxdg_toplevel_v6_.get());
-  }
+  LOG(ERROR) << "SetMinimized V5 NotImplemented";
 }
+ 
 
 void XDGSurfaceWrapperImpl::SurfaceMove(WaylandConnection* connection) {
-  if (xdg_toplevel_) {
-    xdg_toplevel_move(xdg_toplevel_.get(), connection_->seat(),
-                      connection_->serial());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_move(zxdg_toplevel_v6_.get(), connection_->seat(),
-                          connection_->serial());
-  }
+  LOG(ERROR) << "SurfaceMove V5 NotImplemented";
 }
 
 void XDGSurfaceWrapperImpl::SurfaceResize(WaylandConnection* connection,
                                           uint32_t hittest) {
-  if (xdg_toplevel_) {
-    xdg_toplevel_resize(xdg_toplevel_.get(), connection_->seat(),
-                        connection_->serial(),
-                        wl::IdentifyDirection(*connection, hittest));
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_resize(zxdg_toplevel_v6_.get(), connection_->seat(),
-                            connection_->serial(),
-                            wl::IdentifyDirection(*connection, hittest));
-  }
+  LOG(ERROR) << "SurfaceResize V5 NotImplemented";
 }
 
 void XDGSurfaceWrapperImpl::SetTitle(const base::string16& title) {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_title(xdg_toplevel_.get(),
-                           base::UTF16ToUTF8(title).c_str());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_title(zxdg_toplevel_v6_.get(),
-                               base::UTF16ToUTF8(title).c_str());
-  }
+  xdg_surface_set_title(xdg_surface_.get(), base::UTF16ToUTF8(title).c_str());
 }
 
 void XDGSurfaceWrapperImpl::AckConfigure() {
-  if (xdg_surface_) {
-    xdg_surface_ack_configure(xdg_surface_.get(), pending_configure_serial_);
-  } else {
-    DCHECK(zxdg_surface_v6_);
-    zxdg_surface_v6_ack_configure(zxdg_surface_v6_.get(),
-                                  pending_configure_serial_);
-  }
+  xdg_surface_ack_configure(xdg_surface_.get(), pending_configure_serial_);
 }
 
 void XDGSurfaceWrapperImpl::SetWindowGeometry(const gfx::Rect& bounds) {
-  if (xdg_surface_) {
-    xdg_surface_set_window_geometry(xdg_surface_.get(), bounds.x(), bounds.y(),
-                                    bounds.width(), bounds.height());
-  } else {
-    DCHECK(zxdg_surface_v6_);
-    zxdg_surface_v6_set_window_geometry(zxdg_surface_v6_.get(), bounds.x(),
-                                        bounds.y(), bounds.width(),
-                                        bounds.height());
-  }
+  LOG(ERROR) << "SetWindowGeometry V5 NotImplemented";
 }
 
 void XDGSurfaceWrapperImpl::SetMinSize(int32_t width, int32_t height) {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_min_size(xdg_toplevel_.get(), width, height);
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_min_size(zxdg_toplevel_v6_.get(), width, height);
-  }
+ LOG(ERROR) << "SetMinSize V5 NotImplemented";
 }
 
 void XDGSurfaceWrapperImpl::SetMaxSize(int32_t width, int32_t height) {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_max_size(xdg_toplevel_.get(), width, height);
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_max_size(zxdg_toplevel_v6_.get(), width, height);
-  }
+ LOG(ERROR) << "SetMaxSize V5 NotImplemented";
 }
 
 void XDGSurfaceWrapperImpl::SetAppId(const std::string& app_id) {
-  if (xdg_toplevel_) {
-    xdg_toplevel_set_app_id(xdg_toplevel_.get(), app_id.c_str());
-  } else {
-    DCHECK(zxdg_toplevel_v6_);
-    zxdg_toplevel_v6_set_app_id(zxdg_toplevel_v6_.get(), app_id.c_str());
-  }
+  xdg_surface_set_app_id(xdg_surface_.get(), app_id.c_str());
 }
 
 // static
-void XDGSurfaceWrapperImpl::ConfigureStable(void* data,
-                                            struct xdg_surface* xdg_surface,
-                                            uint32_t serial) {
-  auto* surface = static_cast<XDGSurfaceWrapperImpl*>(data);
-  DCHECK(surface);
-  surface->pending_configure_serial_ = serial;
-
-  surface->AckConfigure();
-}
-
-// static
-void XDGSurfaceWrapperImpl::ConfigureTopLevelStable(
-    void* data,
-    struct xdg_toplevel* xdg_toplevel,
-    int32_t width,
-    int32_t height,
-    struct wl_array* states) {
-  auto* surface = static_cast<XDGSurfaceWrapperImpl*>(data);
-  DCHECK(surface);
-
-  bool is_maximized =
-      CheckIfWlArrayHasValue(states, XDG_TOPLEVEL_STATE_MAXIMIZED);
-  bool is_fullscreen =
-      CheckIfWlArrayHasValue(states, XDG_TOPLEVEL_STATE_FULLSCREEN);
-  bool is_activated =
-      CheckIfWlArrayHasValue(states, XDG_TOPLEVEL_STATE_ACTIVATED);
-
-  surface->wayland_window_->HandleSurfaceConfigure(width, height, is_maximized,
-                                                   is_fullscreen, is_activated);
-}
-
-// static
-void XDGSurfaceWrapperImpl::CloseTopLevelStable(
-    void* data,
-    struct xdg_toplevel* xdg_toplevel) {
-  auto* surface = static_cast<XDGSurfaceWrapperImpl*>(data);
-  DCHECK(surface);
-  surface->wayland_window_->OnCloseRequest();
-}
-
-// static
-void XDGSurfaceWrapperImpl::ConfigureV6(void* data,
-                                        struct zxdg_surface_v6* zxdg_surface_v6,
+void XDGSurfaceWrapperImpl::ConfigureV5(void* data,
+                                        struct xdg_surface* xdg_surface_v5,
+                                        int32_t width,
+                                        int32_t height,
+                                        struct wl_array *states,
                                         uint32_t serial) {
   auto* surface = static_cast<XDGSurfaceWrapperImpl*>(data);
   DCHECK(surface);
-  surface->pending_configure_serial_ = serial;
-
-  surface->AckConfigure();
-}
-
-// static
-void XDGSurfaceWrapperImpl::ConfigureTopLevelV6(
-    void* data,
-    struct zxdg_toplevel_v6* zxdg_toplevel_v6,
-    int32_t width,
-    int32_t height,
-    struct wl_array* states) {
-  auto* surface = static_cast<XDGSurfaceWrapperImpl*>(data);
-  DCHECK(surface);
 
   bool is_maximized =
-      CheckIfWlArrayHasValue(states, ZXDG_TOPLEVEL_V6_STATE_MAXIMIZED);
+      CheckIfWlArrayHasValue(states, XDG_SURFACE_STATE_MAXIMIZED);
   bool is_fullscreen =
-      CheckIfWlArrayHasValue(states, ZXDG_TOPLEVEL_V6_STATE_FULLSCREEN);
+      CheckIfWlArrayHasValue(states, XDG_SURFACE_STATE_FULLSCREEN);
   bool is_activated =
-      CheckIfWlArrayHasValue(states, ZXDG_TOPLEVEL_V6_STATE_ACTIVATED);
+      CheckIfWlArrayHasValue(states, XDG_SURFACE_STATE_ACTIVATED);
 
+  surface->pending_configure_serial_ = serial;
   surface->wayland_window_->HandleSurfaceConfigure(width, height, is_maximized,
                                                    is_fullscreen, is_activated);
+  surface->AckConfigure();
 }
 
 // static
-void XDGSurfaceWrapperImpl::CloseTopLevelV6(
-    void* data,
-    struct zxdg_toplevel_v6* zxdg_toplevel_v6) {
+void XDGSurfaceWrapperImpl::CloseV5(void *data, struct xdg_surface *xdg_surface) {
   auto* surface = static_cast<XDGSurfaceWrapperImpl*>(data);
   DCHECK(surface);
   surface->wayland_window_->OnCloseRequest();
 }
 
-zxdg_surface_v6* XDGSurfaceWrapperImpl::zxdg_surface() const {
-  DCHECK(zxdg_surface_v6_);
-  return zxdg_surface_v6_.get();
-}
-
 xdg_surface* XDGSurfaceWrapperImpl::xdg_surface() const {
   DCHECK(xdg_surface_);
   return xdg_surface_.get();
 }
 
-bool XDGSurfaceWrapperImpl::InitializeStable(bool with_toplevel) {
+bool XDGSurfaceWrapperImpl::InitializeV5(bool with_toplevel) {
   static const xdg_surface_listener xdg_surface_listener = {
-      &XDGSurfaceWrapperImpl::ConfigureStable,
-  };
-  static const xdg_toplevel_listener xdg_toplevel_listener = {
-      &XDGSurfaceWrapperImpl::ConfigureTopLevelStable,
-      &XDGSurfaceWrapperImpl::CloseTopLevelStable,
+      &XDGSurfaceWrapperImpl::ConfigureV5,
+      &XDGSurfaceWrapperImpl::CloseV5
   };
 
   // if this surface is created for the popup role, mark that it requires
   // configuration acknowledgement on each configure event.
   surface_for_popup_ = !with_toplevel;
 
-  xdg_surface_.reset(xdg_wm_base_get_xdg_surface(connection_->shell(),
-                                                 wayland_window_->surface()));
-  if (!xdg_surface_) {
-    LOG(ERROR) << "Failed to create xdg_surface";
-    return false;
-  }
-  xdg_surface_add_listener(xdg_surface_.get(), &xdg_surface_listener, this);
-  // XDGPopup requires a separate surface to be created, so this is just a
-  // request to get an xdg_surface for it.
-  if (surface_for_popup_) {
-    connection_->ScheduleFlush();
-    return true;
-  }
-
-  xdg_toplevel_.reset(xdg_surface_get_toplevel(xdg_surface_.get()));
-  if (!xdg_toplevel_) {
-    LOG(ERROR) << "Failed to create xdg_toplevel";
-    return false;
-  }
-  xdg_toplevel_add_listener(xdg_toplevel_.get(), &xdg_toplevel_listener, this);
-  wl_surface_commit(wayland_window_->surface());
+  xdg_surface_.reset(xdg_shell_get_xdg_surface(connection_->shell_v5(),
+                                               wayland_window_->surface()));
 
-  connection_->ScheduleFlush();
-  return true;
-}
-
-bool XDGSurfaceWrapperImpl::InitializeV6(bool with_toplevel) {
-  static const zxdg_surface_v6_listener zxdg_surface_v6_listener = {
-      &XDGSurfaceWrapperImpl::ConfigureV6,
-  };
-  static const zxdg_toplevel_v6_listener zxdg_toplevel_v6_listener = {
-      &XDGSurfaceWrapperImpl::ConfigureTopLevelV6,
-      &XDGSurfaceWrapperImpl::CloseTopLevelV6,
-  };
-
-  // if this surface is created for the popup role, mark that it requires
-  // configuration acknowledgement on each configure event.
-  surface_for_popup_ = !with_toplevel;
+  DCHECK(xdg_surface_);
 
-  zxdg_surface_v6_.reset(zxdg_shell_v6_get_xdg_surface(
-      connection_->shell_v6(), wayland_window_->surface()));
-  if (!zxdg_surface_v6_) {
-    LOG(ERROR) << "Failed to create zxdg_surface";
-    return false;
-  }
-  zxdg_surface_v6_add_listener(zxdg_surface_v6_.get(),
-                               &zxdg_surface_v6_listener, this);
-  // XDGPopupV6 requires a separate surface to be created, so this is just a
-  // request to get an xdg_surface for it.
-  if (surface_for_popup_) {
-    connection_->ScheduleFlush();
-    return true;
-  }
-
-  zxdg_toplevel_v6_.reset(zxdg_surface_v6_get_toplevel(zxdg_surface_v6_.get()));
-  if (!zxdg_toplevel_v6_) {
-    LOG(ERROR) << "Failed to create zxdg_toplevel";
-    return false;
-  }
-  zxdg_toplevel_v6_add_listener(zxdg_toplevel_v6_.get(),
-                                &zxdg_toplevel_v6_listener, this);
-  wl_surface_commit(wayland_window_->surface());
+  xdg_surface_add_listener(xdg_surface_.get(), &xdg_surface_listener, this);
+  // XDGPopup requires a separate surface to be created, so this is just a
 
   connection_->ScheduleFlush();
   return true;
 }
-
 }  // namespace ui
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h
@@ -43,39 +43,19 @@ class XDGSurfaceWrapperImpl : public She
   void SetMaxSize(int32_t width, int32_t height) override;
   void SetAppId(const std::string& app_id) override;
 
-  // xdg_surface_listener
-  static void ConfigureV6(void* data,
-                          struct zxdg_surface_v6* zxdg_surface_v6,
-                          uint32_t serial);
-  static void ConfigureTopLevelV6(void* data,
-                                  struct zxdg_toplevel_v6* zxdg_toplevel_v6,
-                                  int32_t width,
-                                  int32_t height,
-                                  struct wl_array* states);
-
-  static void ConfigureStable(void* data,
-                              struct xdg_surface* xdg_surface,
-                              uint32_t serial);
-  static void ConfigureTopLevelStable(void* data,
-                                      struct xdg_toplevel* xdg_toplevel,
-                                      int32_t width,
-                                      int32_t height,
-                                      struct wl_array* states);
-
-  // xdg_toplevel_listener
-  static void CloseTopLevelStable(void* data,
-                                  struct xdg_toplevel* xdg_toplevel);
-  static void CloseTopLevelV6(void* data,
-                              struct zxdg_toplevel_v6* zxdg_toplevel_v6);
+  static void ConfigureV5(void* data,
+                          struct xdg_surface* xdg_surface,
+                          int32_t width,
+			                    int32_t height,
+			                    struct wl_array *states,
+			                    uint32_t serial);
 
+  static void CloseV5(void *data, struct xdg_surface *xdg_surface);                      
+  
   xdg_surface* xdg_surface() const;
-  zxdg_surface_v6* zxdg_surface() const;
 
  private:
-  // Initializes using XDG Shell Stable protocol.
-  bool InitializeStable(bool with_toplevel);
-  // Initializes using XDG Shell V6 protocol.
-  bool InitializeV6(bool with_toplevel);
+  bool InitializeV5(bool with_toplevel);
 
   // Non-owing WaylandWindow that uses this surface wrapper.
   WaylandWindow* const wayland_window_;
@@ -83,10 +63,7 @@ class XDGSurfaceWrapperImpl : public She
 
   uint32_t pending_configure_serial_ = 0;
 
-  wl::Object<zxdg_surface_v6> zxdg_surface_v6_;
-  wl::Object<zxdg_toplevel_v6> zxdg_toplevel_v6_;
   wl::Object<struct xdg_surface> xdg_surface_;
-  wl::Object<xdg_toplevel> xdg_toplevel_;
 
   bool surface_for_popup_ = false;
 
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/BUILD.gn
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/BUILD.gn
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/BUILD.gn
@@ -111,8 +111,6 @@ source_set("wayland") {
     "host/wayland_window_observer.h",
     "host/wayland_zwp_linux_dmabuf.cc",
     "host/wayland_zwp_linux_dmabuf.h",
-    "host/xdg_popup_wrapper_impl.cc",
-    "host/xdg_popup_wrapper_impl.h",
     "host/xdg_surface_wrapper_impl.cc",
     "host/xdg_surface_wrapper_impl.h",
     "host/zwp_text_input_wrapper.h",
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/common/wayland_util.cc
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/common/wayland_util.cc
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/common/wayland_util.cc
@@ -4,8 +4,7 @@
 
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 
-#include <xdg-shell-client-protocol.h>
-#include <xdg-shell-unstable-v6-client-protocol.h>
+#include <xdg-shell-unstable-v5-client-protocol.h>
 
 #include "ui/base/hit_test.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
@@ -19,6 +18,7 @@ const SkColorType kColorType = kBGRA_888
 
 uint32_t IdentifyDirectionStable(int hittest) {
   uint32_t direction = 0;
+/*
   switch (hittest) {
     case HTBOTTOM:
       direction = xdg_toplevel_resize_edge::XDG_TOPLEVEL_RESIZE_EDGE_BOTTOM;
@@ -50,11 +50,13 @@ uint32_t IdentifyDirectionStable(int hit
       direction = xdg_toplevel_resize_edge::XDG_TOPLEVEL_RESIZE_EDGE_NONE;
       break;
   }
+*/
   return direction;
 }
 
 uint32_t IdentifyDirectionV6(int hittest) {
   uint32_t direction = 0;
+/*
   switch (hittest) {
     case HTBOTTOM:
       direction =
@@ -94,16 +96,17 @@ uint32_t IdentifyDirectionV6(int hittest
       break;
   }
   return direction;
+*/
 }
 
 }  // namespace
 
 uint32_t IdentifyDirection(const ui::WaylandConnection& connection,
                            int hittest) {
-  if (connection.shell())
+  //if (connection.shell())
     return IdentifyDirectionStable(hittest);
-  DCHECK(connection.shell_v6());
-  return IdentifyDirectionV6(hittest);
+  //DCHECK(connection.shell_v6());
+  //return IdentifyDirectionV6(hittest);
 }
 
 bool DrawBitmap(const SkBitmap& bitmap, ui::WaylandShmBuffer* out_buffer) {
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/shell_object_factory.h
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/shell_object_factory.h
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/shell_object_factory.h
@@ -31,14 +31,15 @@ class ShellObjectFactory {
   std::unique_ptr<ShellSurfaceWrapper> CreateShellSurfaceWrapper(
       WaylandConnection* connection,
       WaylandWindow* wayland_window);
-
+/*
   // Creates and intitializes a ShellPopupSurface.
   std::unique_ptr<ShellPopupWrapper> CreateShellPopupWrapper(
       WaylandConnection* connection,
       WaylandWindow* wayland_window,
       const gfx::Rect& bounds);
+*/
 };
 
 }  // namespace ui
 
-#endif  // UI_OZONE_PLATFORM_WAYLAND_HOST_SHELL_OBJECT_FACTORY_H_
\ No newline at end of file
+#endif  // UI_OZONE_PLATFORM_WAYLAND_HOST_SHELL_OBJECT_FACTORY_H_
Index: chromium-83.0.4103.61/ui/ozone/platform/wayland/host/wayland_popup.cc
===================================================================
--- chromium-83.0.4103.61.orig/ui/ozone/platform/wayland/host/wayland_popup.cc
+++ chromium-83.0.4103.61/ui/ozone/platform/wayland/host/wayland_popup.cc
@@ -27,7 +27,7 @@ bool WaylandPopup::CreateShellPopup() {
   auto bounds_px = AdjustPopupWindowPosition();
 
   ShellObjectFactory factory;
-  shell_popup_ = factory.CreateShellPopupWrapper(connection(), this, bounds_px);
+//  shell_popup_ = factory.CreateShellPopupWrapper(connection(), this, bounds_px);
   if (!shell_popup_) {
     LOG(ERROR) << "Failed to create Wayland shell popup";
     return false;
Index: chromium-83.0.4103.61/third_party/wayland-protocols/BUILD.gn
===================================================================
--- chromium-83.0.4103.61.orig/third_party/wayland-protocols/BUILD.gn
+++ chromium-83.0.4103.61/third_party/wayland-protocols/BUILD.gn
@@ -18,8 +18,7 @@ wayland_protocol("xdg_output_protocol")
 
 wayland_protocol("xdg_shell_protocol") {
   sources = [
-    "src/stable/xdg-shell/xdg-shell.xml",
-    "src/unstable/xdg-shell/xdg-shell-unstable-v6.xml",
+    "src/unstable/xdg-shell/xdg-shell-unstable-v5.xml",
   ]
 }
 
